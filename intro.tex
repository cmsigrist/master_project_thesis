\chapter{Introduction}

% The introduction is a longer writeup that gently eases the reader into your
% thesis~\cite{dinesh20oakland}. Use the first paragraph to discuss the setting.
% In the second paragraph you can introduce the main challenge that you see.
% The third paragraph lists why related work is insufficient.
% The fourth and fifth paragraphs discuss your approach and why it is needed.
% The sixth paragraph will introduce your thesis statement. Think how you can
% distill the essence of your thesis into a single sentence.
% The seventh paragraph will highlight some of your results

% Your core contribution should be in a subsection and use bullet points when possible. 
% You can refer to sections where the main results are shown. However, the purpose of contributions is 
% not to give an overview of the thesis text. Instead, the goal is to differentiate and crisply summarize the value of the thesis work. 

% You may optionally follow the contribution list with a plan of the thesis, if this adds something over the table of content. 

% This section is usually 3-5 pages.

GraalVM Native Image~\cite{noauthor_native_nodate} compiles Java bytecode ahead of time into a standalone binary that assumes a fixed set of classes. This is known as the \emph{closed-world assumption}. Therefore, Native Image requires all the application's classes to be known at \emph{build time} to mark them as reachable and include them into the image.

The implementation of dynamic features in Java, like reflection, rely on runtime information that is not available at build time. To support these features under the closed-world assumption, Native Image requires reflectively-accessed elements, that is Classes, \emph{Executables} (i.e., Methods and Constructors), and Fields, to be specified in the \emph{reachability metadata}~\cite{noauthor_reachability_nodate}. 
The reachability metadata is passed to the image-build process and indicates which element is reachable at runtime, and, thus, which element must be included into the image. 
The reachability metadata is either provided as a JSON configuration file or, in specific cases, pre-computed from user code. 
Concretely, invoking the method \verb|Class#forName(String)| of the Java Reflection API~\cite{noauthor_core_nodate} for a class \verb|Foo| requires to manually specify the metadata described in Figure~\ref{fig:foo_metadata}.
To help collect the metadata, GraalVM provides a \emph{Tracing Agent}~\cite{noauthor_collect_nodate}. When running an application on a Java Virtual Machine~(JVM), the agent can be attached to the JVM to record the reflectively-accessed elements during an execution run and outputs a JSON reflection configuration to pass to the image-build process.

\begin{figure}[ht]
    \centering
\begin{lstlisting}
{
    "name": "Foo"
}
\end{lstlisting}
    \caption{JSON reflection configuration required to invoke the method \texttt{Class\#forName("Foo")} in Native Image.}
    \label{fig:foo_metadata}
\end{figure}

The inherent trade-off of ahead-of-time~(AOT) compilation is the build time; creating an image is a slow process. Moreover, computing the correct JSON reflection configuration is not a trivial task.
The Tracing Agent can provide for the bulk of the reachability metadata. However, the agent can still miss an element because the JVM does not behave the same way as Native Image, and must be run multiple times to account for different execution paths. The Oracle GraalVM Reachability Metadata git repository~\cite{noauthor_oraclegraalvm-reachability-metadata_2024} is another way to acquire the metadata for well-known open-source libraries but it requires to be manually kept up to date. Due to the long image build time and the issues with metadata collection, computing the correct metadata is a time-consuming process. That is, if a single element is missing from the configuration, the image crashes at runtime, and must be rebuilt from the ground up.
The last problem is the lack of specification. Unlike Java, there is no specification for Native Image's semantics, and compiler optimizations in Native Image can change the semantics of the program. This fact makes debugging the image a hazardous endeavour.

By introducing a new mode to Java that simulates the semantics of Native Image - we refer to Java behaving according to Native Image's semantics as Java under native restrictions - Java can be leveraged to quickly test reachability metadata without the overhead of building a new image each time. 
To simulate the closed-world assumption, Java under native restrictions checks if each reflectively-accessed element is included in the reachability metadata. To address the issue of metadata collection, we implement a Tracing Agent in Java, such that it follows the same path as Java under native restrictions during an execution run.

The first challenge of implementing Java under native restrictions is the lack of specification. To simulate Native Image behaviour we first have to understand and define what is the expected behaviour. 
Moreover, when operating changes on a language runtime as widely used as Java, guaranteeing correctness requires rigorous testing. The Java Compatibility Kit~(JCK), which is a test suite with more than 100'000 tests, is used to verify that Java under native restrictions is as compliant with the Java Language Specification~\cite{noauthor_java_nodate-2} as Native Image is.
The last requirement is to keep changes to Java itself to a minimum. A line of code is introduced in Java only if removing it would break the correctness of the design.

Related\todo{better but find smt else} projects attempt to bridge the gap between static and dynamic compilers for Java by combining both approach. In an nutshell, the aim is to optimizing startup performance and resource utilization with AOT compilation, while adding support for Java runtime features with just-in-time~(JIT) compilation. The premises of this thesis are different. We are already in a fully dynamic environment, and are attempting to restrict Java's dynamic features to behave as if under a closed-world assumption, essentially tackling the problem the other way around. 

This thesis fits in an overall Native Image usability improvement plan. Porting Java to native restrictions enables users to compute metadata with a quicker turnaround. It also enables us to both understand and validate the semantics of Native Image through execution. In turn, having a clear semantics drives the development of Native Image and makes debugging easier, leaving no room for unexpected behaviour.
The way we approached the Java mode is a cross between what could be coined "software archaeology", and "software surgery": we dug into the deepest parts of Java to understand how native restrictions could be applied to very specific pieces of the code.

The main contributions of this thesis are the following:
\begin{itemize}
  \item We implement a Java mode that simulates Native Image's behaviour for dynamic class loading, dynamic invocations and reflection
  \item With this implementation we drive Native Image's semantics, and provide the specification both in written form and with a Technology Compatibility Kit~(TCK) 
  \item We implement a Tracing Agent in Java that follows Native Image's semantics to collect the metadata 
  \item We improve user's workflow by enabling a faster way to compute reachability metadata
\end{itemize}