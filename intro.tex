\chapter{Introduction}

% The introduction is a longer writeup that gently eases the reader into your
% thesis~\cite{dinesh20oakland}. Use the first paragraph to discuss the setting.
% In the second paragraph you can introduce the main challenge that you see.
% The third paragraph lists why related work is insufficient.
% The fourth and fifth paragraphs discuss your approach and why it is needed.
% The sixth paragraph will introduce your thesis statement. Think how you can
% distill the essence of your thesis into a single sentence.
% The seventh paragraph will highlight some of your results

% Your core contribution should be in a subsection and use bullet points when possible. 
% You can refer to sections where the main results are shown. However, the purpose of contributions is 
% not to give an overview of the thesis text. Instead, the goal is to differentiate and crisply summarize the value of the thesis work. 

% You may optionally follow the contribution list with a plan of the thesis, if this adds something over the table of content. 

% This section is usually 3-5 pages.

GraalVM Native Image~\cite{noauthor_native_nodate} compiles Java bytecode into a standalone binary that assumes a fixed set of classes. This is known as the \emph{closed-world assumption}. Therefore, Native Image requires all of the application's classes to be known at \emph{build time} to mark them as reachable and include them into the image.

The implementation of dynamic features in Java, like reflection, rely on runtime information. To support these features under the closed-world assumption, Native Image requires each reflectively-accessed element, that is Class, \emph{Executable} (i.e., Method and Constructor), and Field, to be specified in the \emph{reachability metadata}~\cite{noauthor_reachability_nodate}. 
The reachability metadata is passed to the image-build process and indicates which element is reachable at runtime, and thus, which element must be included in the image. 
The reachability metadata is either provided as a JSON configuration file or, in specific cases, pre-computed from user-code. 
Concretely, invoking the method \verb|Class#forName(String)| of the Java Reflection API~\cite{noauthor_core_nodate} for a class \verb|Foo| requires to manually specify the metadata described in Figure~\ref{fig:foo_metadata} in a \verb|reflect-config.json| file.
To help collect the metadata, GraalVM provides a \emph{Tracing Agent}~\cite{noauthor_collect_nodate}. When running an application on a Java Virtual Machine~(JVM), the agent can be attached to the JVM to record the reflectively-accessed elements during the execution run and output a JSON reflection configuration to pass to the image-build process.

\begin{figure}[ht]
    \centering
\begin{lstlisting}
{
    "name": "Foo"
}
\end{lstlisting}
    \caption{Reflection metadata required to invoke the method \texttt{Class\#forName("Foo")} in Native Image.}
    \label{fig:foo_metadata}
\end{figure}

\todo{introduce problems: with image build time then explain that JSON is a lot of work -> long build time + json is a problem -> hence java mode}
\todo{3rd problem is the absence of specs, 4th agent}

Building an image \todo{much like writing} is a slow process. Moreover, computing the correct JSON reflection configuration is \todo{like everything that use JSON} not a trivial task. While the Tracing Agent can provide for the bulk of the required metadata, it can also sometimes simply miss an element, or must be run multiple time to account for different execution paths.
Due to the long image build time and the issues that can arise during the metadata collection, computing the correct metadata is a time-consuming process. That is, if a single element is missing from the configuration, the image crashes at runtime, and must be rebuilt from the ground up.


By introducing a new mode to Java that simulates the semantics of Native Image, Java can be used to quickly produce and test reachability metadata without the overhead of building a new image each time. For this thesis, we refer to Java behaving according to Native Image's semantics as Java under native restrictions.

\todo{solutions to the problems and then the challenges}
The challenge of implementing a Java mode is the lack of specification. Unlike Java, there is no specification for Native Image's semantics, and compiler optimizations in Native Image can change the semantics of the program. This means that to simulate Native Image behaviour we first have to understand and define what is expected. To accomplish this, we formally write down the semantics of Native Image, and we implement a Technology Compatibility Kit~(TCK), a test suite that represents this same semantics.
Another requirement is to keep changes to Java itself to a minimum, each line introduced must have a clear reason for existing.
Finally, the design must be correct. When operating changes on a language runtime that is as widely used as Java, guaranteeing correctness requires rigorous testing. We use the Java Compatibility Kit~(JCK) - a test suite with more than 100'000 tests - to verify that the Java mode is compliant with the Java Language Specification~\cite{noauthor_java_nodate-2}.

\todo{find another word} Projects attempt to bridge the gap between static and dynamic compilers for Java. Combining both approach aims at optimizing startup performance and resource utilization with ahead-of-time~(AOT) compilation, while adding support for Java runtime features with just-in-time~(JIT) compilation. The premises of this project are different. We are already in a fully dynamic environment, and are attempting to restrict Java dynamic features to behave as if under a closed-world assumption, essentially tackling the problem the other way around.

The thesis fits in an overall Native Image usability improvement plan. Porting Java to native restrictions enables users to compute metadata with a quicker turnaround, and if needed, to attach a debugger to the Java application and compiler rather than use GDB to debug the image. It also enables us to both understand and validate the semantics of Native Image through execution. In turn, having clear semantics drives the development of Native Image and makes debugging easier, leaving no room for unexpected behaviour.
The way we approached the Java mode is a cross between what could be coined "software archaeology", and 
"software surgery": we dug into the deepest parts of Java to understand how native restrictions could be applied to very specific pieces of the code.

The main contributions of this thesis are the following:
\begin{itemize}
  \item We implement a Java mode that simulates Native Image's behaviour for dynamic class loading, dynamic invocations and reflection
  \item With this implementation we drive and provide Native Image's specifications for these features
  \item We improve user's workflow by enabling a faster way to compute reachability metadata and debug reflection issues
  \item \todo{agent}
\end{itemize}

% Paragraph 6: Thesis statement -> "single" sentence
% We introduce a new Java mode that simulates Native Image behaviour by operating in a pseudo closed-world assumption, allowing us to rapidly get the correct metadata configuration and to write specifications.

ni also has an agent that supports
problems agent does not have the semantics has ni, takes a diff path
second agent emits stuff it shouldn't and misses other not integrated into java
the agent is slow.