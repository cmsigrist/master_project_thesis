\chapter{Introduction}

% The introduction is a longer writeup that gently eases the reader into your
% thesis~\cite{dinesh20oakland}. Use the first paragraph to discuss the setting.
% In the second paragraph you can introduce the main challenge that you see.
% The third paragraph lists why related work is insufficient.
% The fourth and fifth paragraphs discuss your approach and why it is needed.
% The sixth paragraph will introduce your thesis statement. Think how you can
% distill the essence of your thesis into a single sentence.
% The seventh paragraph will highlight some of your results

% Your core contribution should be in a subsection and use bullet points when possible. 
% You can refer to sections where the main results are shown. However, the purpose of contributions is 
% not to give an overview of the thesis text. Instead, the goal is to differentiate and crisply summarize the value of the thesis work. 

% You may optionally follow the contribution list with a plan of the thesis, if this adds something over the table of content. 

% This section is usually 3-5 pages.
GraalVM Native Image~\cite{noauthor_native_nodate} is a project developed at Oracle Labs that compiles Java bytecode into a standalone binary. Operating under the closed-world assumption, Native Image requires all the application's classes and libraries \todo{libraries are subsumed by classes?} to be known at \todo{added emph for new terms}\emph{build time}. \todo{which elements} These elements are then marked as reachable and included into the image.
The closed-world assumption means that, to support certain Java features, like reflection, whose implementation rely on runtime information, Native Image also requires reflectively-accessed elements to be specified in the form of reachability metadata\todo{cite}, to be passed to the image-build process. The reachability metadata can be provided as a JSON configuration file or, in specific cases, pre-computed from user-code.
Because building an image can take a long time, the issue is that computing the correct metadata is a time-consuming process. If a single element is missing from the configuration, the image crashes at runtime, and must be rebuilt.
By introducing a new mode to Java that simulates the semantics of Native Image, Java can be used to quickly produce and test reachability metadata without the overhead of building a new image each time. For this thesis, we refer to Java behaving according to Native Image's semantics as Java under native restrictions.

The main challenge of implementing a Java mode is the lack of specification. Unlike Java, there is no specification for Native Image's semantics, and compiler optimizations in Native Image can change the semantics of the program. This means that to simulate Native Image behaviour we first have to understand and define what is expected. To accomplish this, we formally write down the semantics of Native Image, and we implement a Technology Compatibility Kit~(TCK), a test suite that represents this same semantics.
Another requirement is to keep changes to Java itself to a minimum, each line introduced must have a clear reason for existing.
Finally, the design must be correct. When operating changes on a language runtime that is as widely used as Java, guaranteeing correctness requires rigorous testing. We use the Java Compatibility Kit~(JCK) - a test suite with more than 100'000 tests - to verify that the Java mode is compliant with the Java Language Specification~\cite{noauthor_java_nodate-2}.

Many projects attempt to bridge the gap between static and dynamic compilers for Java. Combining both approach aims at optimizing startup performance and resource utilization with ahead-of-time~(AOT) compilation, while adding support for Java runtime features with just-in-time~(JIT) compilation. The premises of this project are different. We are already in a fully dynamic environment, and are attempting to restrict Java dynamic features to behave as if under a closed-world assumption, essentially tackling the problem the other way around.

The thesis fits in an overall Native Image usability improvement plan. Porting Java to native restrictions enables users to compute metadata with a quicker turnaround, and if needed, to attach a debugger to the Java application and compiler rather than use GDB to debug the image. It also enables us to both understand and validate the semantics of Native Image through execution. In turn, having clear semantics drives the development of Native Image and makes debugging easier, leaving no room for unexpected behaviour.
The way we approached the Java mode is a cross between what could be coined "software archaeology", and 
"software surgery": we dug into the deepest parts of Java to understand how native restrictions could be applied to very specific pieces of the code.

The main contributions of this thesis are the following:
\begin{itemize}
  \item We implement a Java mode that can simulate Native Image's behaviour for dynamic class loading, dynamic invocations and reflection
  \item With this implementation we drive and provide Native Image's specifications for these features
  \item We improve user's workflow by enabling a faster way to compute reachability metadata and debug reflection issues
\end{itemize}

% Paragraph 6: Thesis statement -> "single" sentence
% We introduce a new Java mode that simulates Native Image behaviour by operating in a pseudo closed-world assumption, allowing us to rapidly get the correct metadata configuration and to write specifications.
 
% Add restriction on Java so that it can be statically analysed → write specs so that it’s easily transferable

