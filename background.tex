\chapter{Background}
% The background section introduces the necessary background to understand your
% work. This is not necessarily related work but technologies and dependencies
% that must be resolved to understand your design and implementation.
% This section is usually 3-5 pages.

\section{Java Virtual Machine}
Following the "write once, run anywhere" adage, the typical way of running a Java application is with a Java Virtual Machine~(JVM).
The JVM offers an additional, target independent, layer of abstraction between implementation of 
the Java Language Specifications~\cite{noauthor_java_nodate} and the operating system itself. 
The JVM Specifications~\cite{noauthor_java_nodate-1} describe in details the requirements for a JVM. 
This thesis focuses on a particular implementation, mainly Oracle's Java HotSpot~\cite{noauthor_hotspot_nodate}. 
To achieve high performances, HotSpot relies on tiered compilation. It consists of an interpreter, and two JIT compilers: C1 and C2. 
C1 compiles bytecode with a minimal time and space overhead, applying only a limited set of optimizations. C2, on the other 
hand, is more aggressive and heavily optimizes the code, thus requiring more resources.
The VM starts by interpreting the bytecodes and collects profiling information at the same time. When a part of the code is 
deemed "hot" enough (from the collected profiles), C1 kicks in and starts compiling it. Once a threshold has been crossed C2 
recompiles the same code into a more optimized form. If an optimization done by the compiler is proven wrong, the code is 
deoptimized and and the process is restarted with interpretations.  

\section{GraalVM}
GraalVM is a JDK developed at Oracle Labs.

GraalVM compiles your Java applications ahead of time into standalone binaries. These binaries are smaller, start up to 100x faster, provide peak performance with no warmup, and use less memory and CPU than applications running on a Java Virtual Machine (JVM).

# Matthieu Bovel
GraalVM is a runtime developed by Oracle Labs made of several interconnected components. The main ones are:
• The Graal compiler is the core of the system. It consists of 1. an intermediate representation (IR) allowing
speculative optimizations [3], 2. many optimization passes that can be applied to it and 3. the necessary
machinery to lower it to x86 64-bit machine code. It can either integrate with HotSpot/OpenJDK, serving
as a top-tier just-in-time compiler (replacing C2), or with native image for ahead-of-time compilation. We
present the Graal IR in section 2.2.
GraalVM Native Image [39] known internally as Substrate VM (SVM) is a framework that allows AOT
compilation of JVM-based applications into executable images under closed-world assumption. This lowers
the startup time.

\cite{wimmer_initialize_2019}
 Some language platforms, such as Java VMs and .NET, are particularly slow at
startup because they perform expensive code verification, class loading, bytecode interpretation,
profiling, and dynamic compilation.

novel approach for reducing the startup time and memory footprint:
combining points-to analysis, application initialization at build time, heap snapshotting, and ahead-
of-time (AOT) compilation. 
Our approach is based on a closed-world assumption, i.e., all Java classes must be
known and available at build time. At build time, the Java application and all its libraries (including
the JDK) are processed by the points-to analysis to find the reachable program elements (classes,
methods, and fields), so that only the necessary methods of Java classes are compiled.
Initialization code of the application can run at build time instead of at run time. The application
can control what is initialized and allocate Java objects to build complex data structures. These
objects are available at run time using a so-called image heap, a pre-initialized part of the heap that
is part of the executable and available immediately at application startup. The points-to analysis
can make objects reachable in the image heap, and the snapshotting that builds the image heap can
make new methods reachable for the points-to analysis. These steps are executed iteratively until a
fixed point is reached.

\subsection{Graal Compiler}
\cite{wimmer_initialize_2019}
The GraalVM compiler performs all standard optimizations such as method inlining, constant
folding and arithmetic optimizations, loop optimizations; and optimizations that are especially
effective for object-oriented Java code such as partial escape analysis
\subsection{GraalVM Native Image}

Native Image\cite{noauthor_native_nodate, noauthor_native_nodate-1} is a technology to compile Java code ahead-of-time to a binary – a native executable. A native executable includes only the code required at run time, that is the application classes, standard-library classes, the language runtime, and statically-linked native code from the JDK.
An executable file produced by Native Image has several important advantages, in that it

Uses a fraction of the resources required by the Java Virtual Machine, so is cheaper to run
Starts in milliseconds
Delivers peak performance immediately, with no warmup
Can be packaged into a lightweight container image for fast and efficient deployment
Presents a reduced attack surface
Menttion Substrate VM and all the substitution

During the image build, Native Image may execute user code. This code can have side effects, such as writing a value to a static field of a class. We say that this code is executed at build time. Values written to static fields by this code are saved in the image heap. Run time refers to code and state in the binary when it is executed.

\section{Java dynamic features}
One of the cornerstone of the Java ecosystem is its dynamic feature. Jar, resources, proxy can be loaded, methods can be invoked at runtime, without the compiler having seen them before. 

\subsection{Class Loading, Linking and Initialization}
Dynamic class loading as defined in Java requires the ability to handle a sequence of bytecodes representing a class unseen by the compiler before, at runtime allows to install software componenetsw at runtime (@see Dynamic Class Loading in the JavaTMVirtual Machine)

Class 
talk about classloaders (mention delagation model -> useful for implementation), loading, linking (verifying, preparing, and resolving) and initialisation
The defining loader of D is used to load and thereby create a class or interface denoted [JVM specs] 
There are two kinds of class loaders: the bootstrap class loader supplied by the Java Virtual Machine, and user-defined class loaders. Every user-defined class loader is an instance of a subclass of the abstract class ClassLoader. Applications employ user-defined class loaders in order to extend the manner in which the Java Virtual Machine dynamically creates classes. User-defined class loaders can be used to create classes that originate from user-defined sources. For example, a class could be downloaded across a network, generated on the fly, or extracted from an encrypted file. 
When the Java Virtual Machine asks a class loader L to locate a binary representation for a class or interface called N, L loads the class or interface C denoted by N. L may load C directly, by locating a binary representation and asking the Java Virtual Machine to derive and create C from the binary representation. Alternatively, L may load C indirectly, by delegating to another class loader which loads C directly or indirectly. 


The Java Virtual Machine uses one of three procedures to create a class or interface C denoted by the name N in the run-time constant pool of a class or interface D (D triggered the class loading):

    If N denotes either a nonarray class or an interface, and D was defined by the bootstrap class loader, then the bootstrap class loader initiates loading of C (§5.3.1).

    If N denotes either a nonarray class or an interface, and D was defined by a user-defined class loader, then that same user-defined class loader initiates loading of C (§5.3.2).

    If N denotes an array class, then the Java Virtual Machine creates an array class C denoted by N, in association with the defining loader of D (§5.3.3). 
with user defined class loader:
Otherwise, the Java Virtual Machine invokes the loadClass method of class ClassLoader on L, passing the name N of a class or interface. L must perform one of the following two operations to load and thereby create a class or interface C:

    The class loader L can load C directly. This is accomplished by obtaining an array of bytes that purports to represent C as a ClassFile structure (§4.1), and then invoking the method defineClass of class ClassLoader. Invoking defineClass causes the Java Virtual Machine to derive a class or interface C denoted by N from the array of bytes using L, and then to create C, via the algorithm of §5.3.5. L should use the result of defineClass as the result of loadClass.

    The class loader L can load C indirectly, by delegating the loading of C to some other class loader L'. This is accomplished by passing the argument N to an invocation of a method on L' (typically the loadClass method of class ClassLoader). L should use the result of that method as the result of loadClass.

If C has a direct superclass, the symbolic reference from C to its direct superclass is resolved using the algorithm of §5.4.3.1. 

Linking a class or interface involves verifying and preparing that class or interface, its direct superclass, its direct superinterfaces, and its element type (if it is an array type), if necessary. Linking also involves resolution of symbolic references in the class or interface, though not necessarily at the same time as the class or interface is verified and prepared. 

This specification allows an implementation flexibility as to when linking activities (and, because of recursion, loading) take place, provided that all of the following properties are maintained:

    A class or interface is completely loaded before it is linked.

    A class or interface is completely verified and prepared before it is initialized.

    Errors detected during linkage are thrown at a point in the program where some action is taken by the program that might, directly or indirectly, require linkage to the class or interface involved in the error.

    A symbolic reference to a dynamically-computed constant is not resolved until either (i) an ldc, ldc_w, or ldc2_w instruction that refers to it is executed, or (ii) a bootstrap method that refers to it as a static argument is invoked.

    A symbolic reference to a dynamically-computed call site is not resolved until a bootstrap method that refers to it as a static argument is invoked.


%% copied from StackOverflow!
\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{resources/class_loading.png}
    \caption{Enter Caption}
    \label{fig:enter-label}
\end{figure}
\subsubsection{Java implementation}
In Java, a class is initialized when it is first used.
\subsubsection{Native Image implementation}
Every Java class used at build time is said to be build-time initialized. Note that merely loading a class does not necessarily initialize it. The static class initializer of build-time initialized classes executes on the JVM running the image build. If a class is initialized at build time, its static fields are saved in the produced binary. At run time, using such a class for the first time does not trigger class initialization.

Static analysis is a process that determines which program elements (classes, methods and fields) are used by an application. These elements are also referred to as reachable code. The analysis itself has two parts:

Scanning the bytecodes of a method to determine what other elements are reachable from it.
Scanning the root objects in the native image heap (i.e., static fields) to determine which classes are reachable from them. It starts from the entry points of the application (i.e., the main method). The newly discovered elements are iteratively scanned until further scanning yields no additional changes in element’s reachability.
Only reachable elements are included in the final image. Once a native image is built, no new elements can be added at run time, for example, through class loading. We refer to this constraint as the closed-world assumption.

\subsection{The invokedynamic instruction}
~\cite{rose_bytecodes_2009}
Talk about the usage, Method Handles and how it required dynamic class loading
The JVM invokedynamic instruction was introduced in Java 7. It makes it possible to resolve method calls dynamically at runtime. method dispatch process by using a user-defined bootstrap method that computes the call target.
The above example uses a LambdaMetafactory to create a CallSite that is used to invoke the target method. It uses a MethodHandles.Lookup to find the target method.
The runtime approach is usually reflection-based and, consequently, inefficient. On the other hand, the compile-time solution is generally relying on code generation at compile-time. 
-> what are the case where it should throw bevaue it interprets user code?

https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-5.html#jvms-5.4.3.6
To resolve an unresolved symbolic reference R to a dynamically-computed constant or call site, there are three tasks. First, R is examined to determine which code will serve as its bootstrap method, and which arguments will be passed to that code. Second, the arguments are packaged into an array and the bootstrap method is invoked. Third, the result of the bootstrap method is validated, and used as the result of resolution.

The first task involves the following steps:

    R gives a symbolic reference to a bootstrap method handle. The bootstrap method handle is resolved (§5.4.3.5) to obtain a reference to an instance of java.lang.invoke.MethodHandle.

    Any exception that can be thrown as a result of failure of resolution of a symbolic reference to a method handle can be thrown in this step.

    If R is a symbolic reference to a dynamically-computed constant, then let D be the type descriptor of the bootstrap method handle. (That is, D is a reference to an instance of java.lang.invoke.MethodType.) The first parameter type indicated by D must be java.lang.invoke.MethodHandles.Lookup, or else resolution fails with a BootstrapMethodError. For historical reasons, the bootstrap method handle for a dynamically-computed call site is not similarly constrained.

    If R is a symbolic reference to a dynamically-computed constant, then it gives a field descriptor.

    If the field descriptor indicates a primitive type, then a reference to the pre-defined Class object representing that type is obtained (see the method isPrimitive in class Class).

    Otherwise, the field descriptor indicates a class or interface type, or an array type. A reference to the Class object representing the type indicated by the field descriptor is obtained, as if by resolution of an unresolved symbolic reference to a class or interface (§5.4.3.1) whose name corresponds to the type indicated by the field descriptor.

    Any exception that can be thrown as a result of failure of resolution of a symbolic reference to a class or interface can be thrown in this step.

    If R is a symbolic reference to a dynamically-computed call site, then it gives a method descriptor.

    A reference to an instance of java.lang.invoke.MethodType is obtained, as if by resolution of an unresolved symbolic reference to a method type (§5.4.3.5) with the same parameter and return types as the method descriptor.

    Any exception that can be thrown as a result of failure of resolution of a symbolic reference to a method type can be thrown in this step.


invokedynamic is a bytecode operation used to call arbitrary method within JVM. The exact method to be called and executed is unknown at a compile-time. Instead it is computed by object implementing CallSite. Thus the dynamic in invokedynamic.

CallSite objects, as any other, have to be instantiated. Boostrap Method is a method which instantiates CallSite objects.

Each invokedynamic has a known bootstrap method given as its compile-time parameter. Whenever a invokedynamic is processed for a first time, appropriate bootstrap method is invoked. As result of boostrap method execution a CallSite object is created. This CallSite object is then cached and associated by JVM to a given invokedynamic operation. From now on, whenever particular invokedynamic call is to be executed, a cached CallSite instance is used to resolve called method.

Majority of boostrap methods are not written directly by end Java programmer. However that doesn't mean they are some rare obscure mechanism. They are created by javac compiler whenever particular java statements are used within source. String concatenation or lambda expression come to mind.

For example lambda expression could be implemented as inner classes. For matter of fact, lambdas are presented to programmers 'as shorthand' to using inner classes. However actual javac implementation, for performance reasons, avoids inner classes by generating lambda code under a static method and using invokedynamic to invoke this method.
\subsubsection{Java implementation}
Talk about the bootstrap method invokers, invokers, lanbdametafactory and altmetafactory and lambdaforms -> interpretation until the lambdaform is
considered to be hot enough to be compiled, customized, uncustomized if needed, cf tiered compilation
\subsubsection{Native Image implementaiton}
Some are compiled at image built time (indy and trusted condy BSM), the other are forced interpreted


\subsection{Reflection}

\subsubsection{Java implementation}

\subsubsection{Native Image implementation}
Reachability Metadata and Tracing Agent

 