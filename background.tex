%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Background}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% The background section introduces the necessary background to understand your
% work. This is not necessarily related work but technologies and dependencies
% that must be resolved to understand your design and implementation.
% This section is usually 3-5 pages.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Java Virtual Machine}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Following the "write once, run anywhere" adage, the typical way of running a Java application is on a JVM.
The JVM offers an additional, target-independent, layer of abstraction between implementations of the Java programming language and the operating system itself.
The JVM is responsible for interpreting and executing Java bytecode, and provides four key components~\cite{dannarapu_jvm_2023-1}: 
the class loader to load classes into memory, the runtime data area (that is, the method area, heap, and stack) to store program data, the execution engine, which reads and executes bytecode instructions, and the garbage collector. The JVM Specifications~\cite{noauthor_java_nodate-1} describe in detail the requirements for a JVM to be compliant. 
The thesis targets a particular implementation, mainly Oracle's Java HotSpot~\cite{noauthor_hotspot_nodate} and its JIT compiler for Java 21. 
HotSpot relies on tiered compilation to optimize code execution. It consists of an interpreter and two JIT compilers: C1 and C2. 
C1 compiles bytecode with a minimal time and space overhead, applying only a limited set of optimizations, while C2 employs a more aggressive optimization strategy, requiring more resources.
The VM starts by interpreting the bytecode to minimize startup time, and collects profiling information at the same time. Using this information, once a method is deemed "hot" enough, C1 kicks in and starts compiling it. When the number of times the methods has been invoked (or the number of back-edges to that method) crosses another threshold, C2 recompiles the same code into a more optimized form. If an optimization is proven wrong, the code is deoptimized and the compiler reverts back to interpretations.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{GraalVM}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
GraalVM is a runtime ecosystem developed by Oracle Labs, and features three core components: the Graal compiler, Truffle~\cite{noauthor_truffle_nodate}, and Native Image.
Graal is a compiler that relies on multiple optimizations phases to produce optimized machine code from bytecode. The compiler operates on a language-agnostic intermediate representation called Graal~IR~\cite{duboscq_graal_2013}. Graal~IR not only facilitates the implementation of speculative optimizations, it also enables Graal to run guest programming languages (e.g., JavaScript, Python, Ruby) on the same JVM. 
The JVMCI~\cite{noauthor_jep_nodate}~(JVM Compiler Interface) API offers mechanisms to access the JVM internal data structures and install compiled code. Through this interface, Graal can integrate as a JIT compiler into HotSpot's system and replace C2. 
Graal can also be integrated with Native Image as the AOT compiler.

Native Image~\cite{wimmer_initialize_2019} is a compilation technology that compiles Java bytecode ahead-of-time into standalone binaries. This approach aims at reducing the startup time and memory footprint of Java applications. Native Image operates under the closed-world assumption, all Java classes, which includes the JDK, must be known at build time to be included in the image.
This also means, that every reflectively-accessed elements must be specified in reachability metadata to be made available to the build process. 
At build time, during static analysis, points-to-analysis and heap snapshotting are iteratively applied so that only reachable code remains in the final image. Additionally, part of the initialization code of the application can be executed at build time rather than at runtime.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Java's Dynamic Features}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
One of the cornerstones of the Java platform is its dynamic features. At run time, JARs, resources, and proxies can be loaded, and methods can be invoked without the compiler having seen them before. In the following section, we will dive deeper into the mechanisms of dynamic class loading and invocation.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Dynamic Class Loading}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Dynamic class loading~\cite{liang_dynamic_1998} allows Java applications to load, link, and initialize classes at runtime. Plugins, for example, can be loaded and unloaded without restarting the application; dependency injection relies on late binding of dependencies, which is made possible with dynamic class loading. 

Class loaders are the underlying mechanism used for loading classes. 
There are two types of class loaders: the bootstrap (or system) class loader, which loads all the system classes, and user-defined class loaders, which load classes from user-defined sources.
Class loaders operate on a delegation model. If a class loader L directly loads C, then L is the \emph{defining loader} of C, otherwise L recursively delegate the loading to another class loader, until the defining loader of C is found. L is an \emph{initiating loader} of C. 
Concretely, a class loader in an instance of a subclass of the class \verb|ClassLoader|. 
Figure~\ref{fig:classloader}, shows the key methods of the class.

\begin{figure}[ht]
    \centering
\begin{lstlisting}[language=Java]
class ClassLoader {
    public Class<?> loadClass(String name);
    protected final Class<?> findLoadedClass(String name);
    static native Class<?> defineClass1(ClassLoader loader, String name, 
                                        byte[] b, int off, int len,
                                        ProtectionDomain pd, String source);
    static native Class<?> defineClass2(ClassLoader loader, String name, 
                                        java.nio.ByteBuffer b,
                                        int off, int len, ProtectionDomain pd,
                                        String source);
    static native Class<?> defineClass0(ClassLoader loader,
                                        Class<?> lookup,
                                        String name,
                                        byte[] b, int off, int len,
                                        ProtectionDomain pd,
                                        boolean initialize,
                                        int flags,
                                        Object classData);
    public static ClassLoader getSystemClassLoader();
    ...
}
\end{lstlisting}
    \caption{Core methods of the \texttt{ClassLoader} class}
    \label{fig:classloader}
\end{figure}


The method \verb|loadClass| is the usual entry point to initiate class loading. It can be called directly from user code, or triggered by a JVM instruction.
When loading a class \verb|C| with the system class loader (see Figure~\ref{fig:class_C}), the JVM first checks with the method \verb|findLoadedClass|, if \verb|C| has already been loaded, in which case it immediately returns the class, otherwise, the class loader attempts to locate the corresponding data. 

Linking a class or interface C is done in three steps: (1) the JVM verifies that the binary representation of the class or interface C is correct, (2) the static fields of C are created and initialized, and (3) symbolic references are resolved into direct references. If C has a direct superclass or superinterface D, then D must also be verified and prepared. 
Once all symbolic references have been resolved, the JVM invokes the method \verb|defineClass0|, \verb|defineClass1| or \verb|defineClass2| to transform the array of bytes into a run-time representation of the class, and returns a \verb|Class| object.

\begin{figure}[ht]
    \centering
\begin{lstlisting}[language=Java]
class C extends D {
}
class Main {
    public static void main(String[] args) {
        ClassLoader cl = ClassLoader.getSystemClassLoader();
        Class<?> c = cl.loadClass("C");
    }
}
\end{lstlisting}
    \caption{Dynamically loading the class C.}
    \label{fig:class_C}
\end{figure}

% \subsubsection{Native Image implementation}
% There are three main cases for how Native Image supports dynamic class loading: (1) the argument passed to \verb|loadClass| is a constant or is effectively constant, the argument is constant folded during static analysis, and gets compiled in the image, (2) the class is included in the reachability metadata, (3) the class is not a constant, nor is it registered, in which case the image will throw an exception at runtime.


% Every Java class used at build time is said to be build-time initialized. Note that merely loading a class does not necessarily initialize it. The static class initializer of build-time initialized classes executes on the JVM running the image build. If a class is initialized at build time, its static fields are saved in the produced binary. At run time, using such a class for the first time does not trigger class initialization.
% 
% Static analysis is a process that determines which program elements (classes, methods and fields) are used by an application. These elements are also referred to as reachable code. The analysis itself has two parts:

% Scanning the bytecodes of a method to determine what other elements are reachable from it.
% Scanning the root objects in the native image heap (i.e., static fields) to determine which classes are reachable from them. It starts from the entry points of the application (i.e., the main method). The newly discovered elements are iteratively scanned until further scanning yields no additional changes in elementâ€™s reachability.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The \texttt{invokedynamic} Instruction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The \verb|invokedynamic| instruction~\cite{noauthor_java_nodate} was introduced to support the invocation of methods without static type information at runtime.
This instruction is distinct from the JVM's traditional method invocation instructions (\verb|invokevirtual|, \verb|invokeinterface|, \verb|invokestatic|, and \verb|invokespecial|) in that it does not bind to a method at compile time. Instead, it defers the decision of which method to invoke until runtime.

At the core of the \verb|invokedynamic|'s resolution mechanism is the bootstrap method. A bootstrap method is a user-defined method that the JVM invokes the first time an \verb|invokedynamic| instruction is executed. Some bootstrap methods are provided by the JVM itself. For example, lambda expressions in Java use the \verb|LambdaMetafactory#metafactory| or \verb|altmetafactory| as their bootstrap methods. 
% Similarly, for performance reasons, the JVM now uses the \verb|invokedynamic| instruction for string concatenation~\cite{noauthor_jep_nodate-1}, the \verb|StringConcatFactory#makeConcat| is the bootstrap method.
This bootstrap method returns a \verb|CallSite| object, which encapsulates a target \verb|MethodHandle|. The \verb|MethodHandle| is a reference to an executable or a field and contains all the necessary mechanisms and data structure to invoke or access the object it references (e.g., the element's defining class, name, type signature, and methods to access it). 

\verb|CallSite| resolution involves three steps: (1) the bootstrap method handle is resolved, meaning all symbolic references to classes, interfaces, fields, and methods, as well as, all classes and interfaces contained in the method descriptor must be resolved, (2) the bootstrap method is invoked, and finally (3) the \verb|CallSite| is verified.
Once resolved, the \verb|CallSite| is cached and associated to a particular \verb|invokedynamic| instruction.
For subsequent invocations, the bootstrap method is not re-executed, instead the method handle encapsulated in the \verb|CallSite| can be directly invoked.

% The main difference between HotSpot's implementation of \verb|invokedynamic| and Native Image's resides in the \verb|CallSite| resolution. Native Image distinguishes how it handles \verb|CallSite| resolution based on whether the bootstrap method is JVM-implemented or not. For trusted, JVM-implemented bootstrap methods, resolution occurs at build time. Otherwise, the bootstrap method is interpreted at runtime and the resolution relies on reflection, requiring the declaring class, the method and the method types to be registered for reflection.

% This MethodHandle effectively directs subsequent invocations of the invokedynamic instruction, bypassing the need for further resolution. The ability to specify the bootstrap method, along with the CallSite and MethodHandle it produces, allows for dynamic language behaviors such as runtime method linking and method invocation based on runtime conditions rather than static analysis.

%    Any exception that can be thrown as a result of failure of resolution of a symbolic reference to a method type can be thrown in this step.


% Each invokedynamic has a known bootstrap method given as its compile-time parameter. Whenever a invokedynamic is processed for a first time, appropriate bootstrap method is invoked. As result of boostrap method execution a CallSite object is created. This CallSite object is then cached and associated by JVM to a given invokedynamic operation. From now on, whenever particular invokedynamic call is to be executed, a cached CallSite instance is used to resolve called method.

% Majority of boostrap methods are not written directly by end Java programmer. However that doesn't mean they are some rare obscure mechanism. They are created by javac compiler whenever particular java statements are used within source. String concatenation or lambda expression come to mind.

% For example lambda expression could be implemented as inner classes. For matter of fact, lambdas are presented to programmers 'as shorthand' to using inner classes. However actual javac implementation, for performance reasons, avoids inner classes by generating lambda code under a static method and using invokedynamic to invoke this method.

% Talk about the bootstrap method invokers, invokers, lanbdametafactory and altmetafactory and lambdaforms -> interpretation until the lambdaform is
% considered to be hot enough to be compiled, customized, uncustomized if needed, cf tiered compilation

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Java Reflection API}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Java reflection provides an API that allows programs to inspect and manipulate objects, mainly Classes, Executables, and Fields at runtime.
Through reflection, Java programs can dynamically load classes, access fields, invoke methods, and create instances of classes with no compile-time dependency. It is also the core mechanism used to implement serialization and annotation processing. Figure~\ref{fig:reflective_calls} shows an example of Java program that uses the reflection API to invoke a method.

\begin{figure}[ht]
    \centering
\begin{lstlisting}[language=Java]
class C {
    public static void greet(String arg) {}
}
class Main {
    public static void main(String[] args) throws Exception {
        Class<?> c = Class.forName("C");
        Method greet = c.getDeclaredMethod("greet", String.class);
        greet.invoke(c, "Hello there!");
    }
}
\end{lstlisting}
    \caption{Using reflection, the class C can be loaded and its \texttt{greet} method invoked at runtime.}
    \label{fig:reflective_calls}
\end{figure}

Implementing reflection in HotSpot is rather straightforward, as every Java object header contains a pointer to the metadata for its declaring class. At runtime, the JVM traverses the pointers until it reaches the object's declaring class~\cite{evans_ben_reflection_nodate}, and returns the queried element.

% [On the other hand, the shared, type-specific metadata is stored in an area called metaspace and every Java object header contains a pointer to the metadata for the class that the object belongs to. This is known as the klass word of the header.
% The fact that every object has a pointer to the shared class metadata means that during code execution, the JVM can always traverse the pointer and access the runtime type information of the class that the object belongs to.] copy pasted from~\cite{evans_ben_reflection_nodate} 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Native Image's Implementation of Reflection and Java's Dynamic Features}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Reflection, dynamic class loading and dynamic invocation all require runtime information that Native Image does not have at build time. Therefore, reflectively-accessed element must be provided as reachability metadata, which can be user-provided in the form of a JSON configuration file.  
Figure~\ref{fig:reflective_calls}, for example, would require the following entries to be specified in a \verb|META-INF/native-image/reflect-config.json| file placed at the root of the project:

\begin{figure}[ht]
    \centering
\begin{lstlisting}
[{
    "name":"C",
    "methods": [{"name": "greet", parameterTypes: ["java.lang.String"]}]
}]    
\end{lstlisting}
    \caption{Reflection configuration to load the class C and invoke its method greet.}
    \label{fig:reflect_config}
\end{figure}

To help capture this metadata, GraalVM provides a Tracing Agent. Through the JVM Tool Interface~\cite{noauthor_jvmtm_nodate}, a native library, or \emph{agent}, can attach to the JVM, and access and control the state of the applications running on the JVM. GraalVM's Tracing Agent introduces a list breakpoints for each method of the Java Reflection API to stop the JVM and record the reflectively-accessed elements. When the execution run has finished, the agent outputs a JSON reflection configuration that can be passed to the image-build process.

If the reflectively-accessed element is passed as a constant or effectively constant (see Figure~\ref{fig:computing_reflection_metadata_in_code_code}), the reachability metadata can be pre-computed at build time, and the element does not need to be manually included in the JSON configuration. 

\begin{figure}[ht]
    \centering
\begin{lstlisting}[language=Java]
public static void main(String[] args) {
    Class.forName("java.lang.String")
    String.class.getDeclaredMethod("length", String.class)
}    
\end{lstlisting}
    \caption{The reflective accesses are done on constant arguments that get constant-folded at image build time, as such, the reachability metadata are pre-computed in user code.}
    \label{fig:computing_reflection_metadata_in_code_code}
\end{figure}

% Under the closed-world assumption no new element can be included in the universe after the image build time. Instead, to implement Java dynamic features Native Image relies on reflection\todo{what reflection?}. 
There are three main cases for how Native Image supports dynamic class loading: (1) the argument passed to \verb|loadClass| is a constant, it is constant-folded during static analysis and compiled in the image, (2) the class is included in the reachability metadata, (3) the class is not a constant, nor is it registered, in which case the image will throw an exception at runtime.

For the \verb|invokedynamic| instruction, the main difference between HotSpot's implementation and Native Image's resides in the \verb|CallSite| resolution. Native Image distinguishes how it handles \verb|CallSite| resolution based on whether the bootstrap method is JVM-implemented or not. For trusted, JVM-implemented bootstrap methods, resolution occurs at build time. Otherwise, the bootstrap method is interpreted at runtime. The resolution relies on reflection, and requires the declaring class, the method, and the types in the method signature to be registered for reflection.