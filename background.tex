%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Background}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% The background section introduces the necessary background to understand your
% work. This is not necessarily related work but technologies and dependencies
% that must be resolved to understand your design and implementation.
% This section is usually 3-5 pages.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Java Virtual Machine}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Following the "write once, run anywhere" adage, the typical way of running a Java application is with a Java Virtual Machine~(JVM).
The JVM offers an additional, target independent, layer of abstraction between implementation of 
the Java programming language~\cite{noauthor_java_nodate-2} and the operating system itself.
It is responsible for interpreting and executing Java code, and provides four key components: 
the class loader, to load classes into memory, the runtime data area, to store program data (that is the method area, heap, and stack), the execution engine, which reads and executes bytecode instructions, and the garbage collector. The JVM Specifications~\cite{noauthor_java_nodate-1} describe in details the requirements for a JVM. 
This thesis focuses on a particular implementation, mainly Oracle's Java HotSpot~\cite{noauthor_hotspot_nodate} and its Just-In-Time~(JIT) compiler. 
HotSpot relies on tiered compilation to optimize code execution. It consists of an interpreter, and two JIT compilers: C1 and C2. 
C1 compiles bytecode with a minimal time and space overhead, applying only a limited set of optimizations, while C2 employs a more aggressive optimization strategy, requiring more resources.
The VM starts by interpreting the bytecodes to minimize startup time, and collects profiling information at the same time. Using these information, once a method is deemed "hot" enough, C1 kicks in and starts compiling it. When another threshold has been crossed C2 
recompiles the same code into a more optimized form. If an optimization is proven wrong, the code is 
deoptimized and the compiler reverts back to interpretations.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{GraalVM}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
GraalVM is a runtime ecosystem developed by Oracle Labs, and features two core components: the Graal compiler, and Native Image.
Graal is a compiler that relies on multiple optimizations stages, known as "Phases", to produce optimized machine code from bytecodes. The compiler operates on a language-agnostic intermediate representation called Graal~IR~\cite{duboscq_graal_nodate}. This graph-based representation not only facilitates the implementation of both standard and aggressive speculative optimizations, it also enables Graal to run guest programming languages (e.g. JavaScript, Python, Ruby) on the same JVM. 
The JVMCI~\cite{noauthor_jep_nodate}~(JVM Compiler Interface) API offers mechanisms to access the JVM internal data structures and install compiled code. Through this interface, Graal can integrate as a JIT compiler into HotSpot's system and replace C2. 
Graal can also be integrated with Native Image as the AOT compiler.

Native Image~\cite{wimmer_initialize_2019} is a compilation technology that compiles Java programs ahead-of-time into native binaries. This approach aims at reducing the startup time and memory footprint of the image. Native Image operates under a closed-world assumption, this means that all Java classes and all the application's libraries, which includes the JDK, must be known at image build time to be included in the image. This information is made available to the build process through reachability metadata. 
At build time during static analysis, points-to-analysis and heap snapshotting are iteratively applied such that only reachable code remains in the final image. Additionally, part of the initialization code of the application can be executed at build time rather than at runtime.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Java's Dynamic Features}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
One of the cornerstone of the Java platform is its dynamic features. At runtime JARs, resources, and proxies can be loaded, and methods can be invoked without the compiler having seen them before. In the following section, we will dive deeper into the mechanisms of dynamic class loading and invocation.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Dynamic Class Loading}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Dynamic class loading~\cite{liang_dynamic_nodate} allows Java applications to load, link, and initialize classes at runtime, and more generally to install software components at runtime. Plugins for examples can be loaded and unloaded without restarting the application; dependency injection relies on late binding of dependencies, which is made possible with dynamic class loading. 

Class loaders are the underlying mechanism used for loading classes. 
There are two types of class loaders: the bootstrap (or system) class loader, which loads all the system classes, and user-defined class loaders, which load classes from user-defined sources.
Class loaders operate on a delegation model. If a class loader L directly loads C, then L in the \textit{defining loader} of C, otherwise L recursively delegate the loading to another class loader, until the defining loader of C is found. L is an \textit{initiating loader} of C. 

Linking a class or interface C is done in three steps: (1) the JVM first verifies that the binary representation of the class or interface C is correct, (2) the static fields of C are created and initialized, (3) symbolic references are resolved into direct references. If C has a direct superclass or superinterface D, then D must also be verified and prepared. 

% "Resolution is the process of dynamically determining one or more concrete values from a symbolic reference in the run-time constant pool. Initially, all symbolic references in the run-time constant pool are unresolved." [copy pasted from specifications]  
Concretely, a class loader in an instance of a subclass of the class \verb|ClassLoader|. 
Figure~\ref{fig:classloader}, shows the key methods of the class.

\begin{figure}[ht]
    \centering
\begin{lstlisting}[language=Java]
class ClassLoader {
    public Class<?> loadClass(String name);
    protected final Class<?> findLoadedClass(String name);
    static native Class<?> defineClass1(ClassLoader loader, String name, 
                                        byte[] b, int off, int len,
                                        ProtectionDomain pd, String source);
    static native Class<?> defineClass2(ClassLoader loader, String name, 
                                        java.nio.ByteBuffer b,
                                        int off, int len, ProtectionDomain pd,
                                        String source);
    static native Class<?> defineClass0(ClassLoader loader,
                                        Class<?> lookup,
                                        String name,
                                        byte[] b, int off, int len,
                                        ProtectionDomain pd,
                                        boolean initialize,
                                        int flags,
                                        Object classData);
    public static ClassLoader getSystemClassLoader();
    ...
}
\end{lstlisting}
    \caption{Core methods of the \texttt{ClassLoader} class}
    \label{fig:classloader}
\end{figure}


The method \verb|loadClass| is the usual entry point to initiate class loading. It can be called directly from user code, or triggered by a JVM instruction.
When loading a class \verb|C| with the system class loader (see Figure~\ref{fig:class_C}), the JVM first checks with the method \verb|findLoadedClass|, if \verb|C| has already been loaded, in which case it immediately returns the class, otherwise, the class loader attempts to locate the corresponding data. When linking C, the superclass D must also be linked. Once all, symbolic references have been resolved, the JVM invoke the method \verb|defineClass0|, \verb|defineClass1| or \verb|defineClass2| to transform the array of bytes into a run-time representation of the class, and returns a \verb|Class| object.

\begin{figure}[ht]
    \centering
\begin{lstlisting}[language=Java]
class C extends D {
}
class Main {
    public static void main(String[] args) {
        ClassLoader cl = ClassLoader.getSystemClassLoader();
        Class<?> c = cl.loadClass("C");
    }
}
\end{lstlisting}
    \caption{Dynamically loading the class C.}
    \label{fig:class_C}
\end{figure}

% \subsubsection{Native Image implementation}
% There are three main cases for how Native Image supports dynamic class loading: (1) the argument passed to \verb|loadClass| is a constant or is effectively constant, the argument is constant folded during static analysis, and gets compiled in the image, (2) the class is included in the reachability metadata, (3) the class is not a constant, nor is it registered, in which case the image will throw an exception at runtime.


% Every Java class used at build time is said to be build-time initialized. Note that merely loading a class does not necessarily initialize it. The static class initializer of build-time initialized classes executes on the JVM running the image build. If a class is initialized at build time, its static fields are saved in the produced binary. At run time, using such a class for the first time does not trigger class initialization.
% 
% Static analysis is a process that determines which program elements (classes, methods and fields) are used by an application. These elements are also referred to as reachable code. The analysis itself has two parts:

% Scanning the bytecodes of a method to determine what other elements are reachable from it.
% Scanning the root objects in the native image heap (i.e., static fields) to determine which classes are reachable from them. It starts from the entry points of the application (i.e., the main method). The newly discovered elements are iteratively scanned until further scanning yields no additional changes in element’s reachability.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The invokedynamic Instruction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The \verb|invokedynamic| instruction was introduced to support the invocation of methods without static type information~\cite{noauthor_java_nodate} at runtime.
This instruction is distinct from the JVM's traditional method invocation instructions (\verb|invokevirtual|, \verb|invokeinterface|, \verb|invokestatic|, and \verb|invokespecial|) in that it does not bind to a method at compile time. Instead, it defers the decision of which method to invoke to runtime.

At the core of the \verb|invokedynamic|'s resolution mechanism is the bootstrap method. A bootstrap method is a user-defined method that the JVM invokes the first time an \verb|invokedynamic| instruction is executed. 
This method returns a \verb|CallSite| object, which encapsulates a target \verb|MethodHandle|. The \verb|MethodHandle| is a reference to an Executable or a Field and contains all the necessary structures and data to invoke or access the object it references (e.g. the defining class, the Executable name and type signature, invoker methods). 

\verb|CallSite| resolution involves three steps: (1) the bootstrap method handle is resolved, meaning all symbolic references to classes, interfaces, fields, and methods, as well as, all classes and interfaces contained in the method descriptor must be resolved, (2) the bootstrap method is invoked, and finally (3) the \verb|CallSite| is verified.
Once resolved, the \verb|CallSite| is cached and associated to a particular \verb|invokedynamic| instruction.
For subsequent invocations, the bootstrap method is not re-excuted, instead the method handle encapsulated in the \verb|CallSite| can be directly invoked.

Certain bootstrap methods are provided by the JVM itself. For example, lambda expressions in Java use the \verb|LambdaMetafactory#metafactory| or \verb|altmetafactory| as their bootstrap methods. Similarly, for performance reasons, the JVM uses the \verb|invokedynamic| instruction for string concatenation, the \verb|StringConcatFactory#makeStringConcat| is the bootstrap method.

% The main difference between HotSpot's implementation of \verb|invokedynamic| and Native Image's resides in the \verb|CallSite| resolution. Native Image distinguishes how it handles \verb|CallSite| resolution based on whether the bootstrap method is JVM-implemented or not. For trusted, JVM-implemented bootstrap methods, resolution occurs at build time. Otherwise, the bootstrap method is interpreted at runtime and the resolution relies on reflection, requiring the declaring class, the method and the method types to be registered for reflection.

% This MethodHandle effectively directs subsequent invocations of the invokedynamic instruction, bypassing the need for further resolution. The ability to specify the bootstrap method, along with the CallSite and MethodHandle it produces, allows for dynamic language behaviors such as runtime method linking and method invocation based on runtime conditions rather than static analysis.

%https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-5.html#jvms-5.4.3.6
%To resolve an unresolved symbolic reference R to a dynamically-computed constant or call site, there are three tasks. First, R is examined to determine which code will serve as its bootstrap method, and which arguments will be passed to that code. Second, the arguments are packaged into an array and the bootstrap method is invoked. Third, the result of the bootstrap method is validated, and used as the result of resolution.
%
%The first task involves the following steps:
%
%    R gives a symbolic reference to a bootstrap method handle. The bootstrap method handle is resolved (§5.4.3.5) to obtain a reference to an instance of java.lang.invoke.MethodHandle.
%
%    Any exception that can be thrown as a result of failure of resolution of a symbolic reference to a method handle can be thrown in this step.
%
%    If R is a symbolic reference to a dynamically-computed constant, then let D be the type descriptor of the bootstrap method handle. (That is, D is a reference to an instance of java.lang.invoke.MethodType.) The first parameter type indicated by D must be java.lang.invoke.MethodHandles.Lookup, or else resolution fails with a BootstrapMethodError. For historical reasons, the bootstrap method handle for a dynamically-computed call site is not similarly constrained.
%
%    If R is a symbolic reference to a dynamically-computed constant, then it gives a field descriptor.
%
%    If the field descriptor indicates a primitive type, then a reference to the pre-defined Class object representing that type is obtained (see the method isPrimitive in class Class).
%
%    Otherwise, the field descriptor indicates a class or interface type, or an array type. A reference to the Class object representing the type indicated by the field descriptor is obtained, as if by resolution of an unresolved symbolic reference to a class or interface (§5.4.3.1) whose name corresponds to the type indicated by the field descriptor.
%
%    Any exception that can be thrown as a result of failure of resolution of a symbolic reference to a class or interface can be thrown in this step.
%
%    If R is a symbolic reference to a dynamically-computed call site, then it gives a method descriptor.
%
%    A reference to an instance of java.lang.invoke.MethodType is obtained, as if by resolution of an unresolved symbolic reference to a method type (§5.4.3.5) with the same parameter and return types as the method descriptor.


%    Any exception that can be thrown as a result of failure of resolution of a symbolic reference to a method type can be thrown in this step.


% Each invokedynamic has a known bootstrap method given as its compile-time parameter. Whenever a invokedynamic is processed for a first time, appropriate bootstrap method is invoked. As result of boostrap method execution a CallSite object is created. This CallSite object is then cached and associated by JVM to a given invokedynamic operation. From now on, whenever particular invokedynamic call is to be executed, a cached CallSite instance is used to resolve called method.

% Majority of boostrap methods are not written directly by end Java programmer. However that doesn't mean they are some rare obscure mechanism. They are created by javac compiler whenever particular java statements are used within source. String concatenation or lambda expression come to mind.

% For example lambda expression could be implemented as inner classes. For matter of fact, lambdas are presented to programmers 'as shorthand' to using inner classes. However actual javac implementation, for performance reasons, avoids inner classes by generating lambda code under a static method and using invokedynamic to invoke this method.

% Talk about the bootstrap method invokers, invokers, lanbdametafactory and altmetafactory and lambdaforms -> interpretation until the lambdaform is
% considered to be hot enough to be compiled, customized, uncustomized if needed, cf tiered compilation

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Java Reflection API}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Java reflection provides an API that allows programs to inspect and manipulate objects, mainly classes, executables and fields, at runtime.
Through reflection, Java programs can dynamically load classes, access fields, invoke methods, and create instances of classes with no compile-time dependency. It is also the core mechanism to implement serialization and annotation processing.
Reflection allows for the development of flexible and generic code that can interact with unknown classes at runtime. Figure~\ref{fig:reflective_calls} is a small example of such an application.

\begin{figure}[ht]
    \centering
\begin{lstlisting}[language=Java]
class Foo {
    public static void greet(String arg);
}
class Main {
    public static void main(String[] args) throws Exception {
        Method greet = Class.forName("Foo").getDeclaredMethod("greet");
        greet.invoke("Hello there!");
    }  
}
\end{lstlisting}
    \caption{Using reflection, the class Foo can be loaded and its greet method invoked at runtime.}
    \label{fig:reflective_calls}
\end{figure}

Implementing reflection in HotSpot, is rather straightforward. Every Java object header contains a pointer to the metadata for its declaring class. At runtime, the JVM can simply traverse the pointer to reach the type information of the object's class~\cite{evans_ben_reflection_nodate}.

% [On the other hand, the shared, type-specific metadata is stored in an area called metaspace and every Java object header contains a pointer to the metadata for the class that the object belongs to. This is known as the klass word of the header.
% The fact that every object has a pointer to the shared class metadata means that during code execution, the JVM can always traverse the pointer and access the runtime type information of the class that the object belongs to.] copy pasted from~\cite{evans_ben_reflection_nodate} 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Native Image's Implementation of Reflection and Java's Dynamic Features}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Reflection, dynamic class loading and dynamic invocation all require runtime information that Native Image does not have at build time.
As mentioned before, every reflectively-accessed element must be provided as reachability metadata.
This reachability metadata can be user-provided in the form of a JSON configuration file.  
Figure~\ref{fig:reflective_calls}, for example, would require the following entries to be specified in
\verb|src/META-INF/native-image/reflect-config.json| file:

\begin{figure}[ht]
    \centering
\begin{lstlisting}
{
    "name":"Foo",
    "methods": [{"name": "greet", parameterTypes: ["java.lang.String"]}]
}    
\end{lstlisting}
    \caption{Reflection configuration to load the class Foo and invoke its method greet.}
    \label{fig:reflect_config}
\end{figure}

To help capture this metadata, GraalVM provides a tracing agent. The tracing attaches to the JVM and tracks all reflection calls to output a reflection configuration.   

% Talk about the reflection metadata parser during analysis and how classes are registered
If the reflectively-accessed element is passed as a constant or effectively constant (see Figure~\ref{fig:computing_reflection_metadata_in_code_code}), the reachability metadata can be pre-computed at build time, and the element does not need to be manually included in the JSON configuration. 

\begin{figure}[ht]
    \centering
\begin{lstlisting}[language=Java]
{
    Class.forName("java.lang.Integer")
    Integer.class.getDeclaredMethod("bitCount", int.class)
}    
\end{lstlisting}
    \caption{Example of reflection metadata pre-computed in user code. The reflective access is done on constant argument that gets constant-folded at image build time.}
    \label{fig:computing_reflection_metadata_in_code_code}
\end{figure}

Under the closed-world assumption no new element can be included in the universe after the image build time. To implement Java dynamic features Native Image relies on another mechanism, mainly reflection. 
There are three main cases for how Native Image supports dynamic class loading: (1) the argument passed to \verb|loadClass| is a constant, it is constant folded during static analysis and gets compiled in the image, (2) the class is included in the reachability metadata, (3) the class is not a constant, nor is it registered, in which case the image will throw an exception at runtime.
For the \verb|invokedynamic| instruction, the main difference between HotSpot's implementation and Native Image's resides in the \verb|CallSite| resolution. Native Image distinguishes how it handles \verb|CallSite| resolution based on whether the bootstrap method is JVM-implemented or not. For trusted, JVM-implemented bootstrap methods, resolution occurs at build time. Otherwise, the bootstrap method is interpreted at runtime and the resolution relies on reflection, requiring the declaring class, the method and the types in the method signature to be registered for reflection.