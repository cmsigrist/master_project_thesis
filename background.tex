%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Background}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% The background section introduces the necessary background to understand your
% work. This is not necessarily related work but technologies and dependencies
% that must be resolved to understand your design and implementation.
% This section is usually 3-5 pages.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Java Virtual Machine}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Following the "write once, run anywhere" adage, the typical way of running a Java application is with a Java Virtual Machine~(JVM).
The JVM offers an additional, target independent, layer of abstraction between implementation of 
the Java programming language~\cite{noauthor_java_nodate-2} and the operating system itself.
The JVM, is responsible for interpreting and executing Java code. It consists in four key components: 
the class loader, to load classes into memory, the runtime data area, to store program data (that is the method area, heap, and stack), the execution engine, which reads and executes bytecode instructions, and the garbage collector. The JVM Specifications~\cite{noauthor_java_nodate-1} describe in details the requirements for a JVM. 
This thesis focuses on a particular implementation, mainly Oracle's Java HotSpot~\cite{noauthor_hotspot_nodate} and its Just-In-Time~(JIT) compiler. 
HotSpot relies on tiered compilation to optimize code execution. It consists of an interpreter, and two JIT compilers: C1 and C2. 
C1 compiles bytecode with a minimal time and space overhead, applying only a limited set of optimizations, while C2 employs a more aggressive optimization strategy, requiring more resources.
The VM starts by interpreting the bytecodes to minimize startup time, and collects profiling information at the same time. Using these information, once a method is deemed "hot" enough, C1 kicks in and starts compiling it. When another threshold has been crossed C2 
recompiles the same code into a more optimized form. If an optimization is proven wrong, the code is 
deoptimized and the compiler reverts back to interpretations.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{GraalVM}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
GraalVM is a runtime ecosystem developed by Oracle Labs, and features two core components: the Graal compiler, and Native Image.
Graal is a JIT compiler that relies on multiple optimizations stages, known as "Phases", to produce optimized machine code from bytecodes. The compiler operates on a language-agnostic intermediate representation called Graal~IR~\cite{duboscq_graal_nodate}. This graph-based representation not only facilitates the implementation of both standard and aggressive speculative optimizations, it also enables Graal to run guest programming languages (JavaScript, Python, Ruby) on the same JVM. 
The JVMCI~\cite{noauthor_jep_nodate} (JVM Compiler Interface) API offers mechanisms to access the JVM internal data structures and install compiled code. Though this interface, Graal can integrate into HotSpot's compiler system and replace C2. 

Native Image~\cite{noauthor_native_nodate, noauthor_native_nodate-1, wimmer_initialize_2019} is a compilation technology that compiles Java programs ahead-of-time into native binaries. This approach aims at reducing the startup time and memory footprint of the image. Native Image operates under a closed-world assumption, this means that all Java classes and all its libraries, which includes the JDK, must be known at image build time to be included in the image. As such, every reflectively-accessed element, i.e, Class, Executable, and Field must be provided as reachability metadata. 
At build time during static analysis, points-to-analysis and heap snapshotting are iteratively applied such that only reachable code remains in the final image. Additionally, part of the initialization code of the application can be executed at build time rather than at runtime.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Java dynamic features}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
One of the cornerstone of Java platform is its dynamic features. At runtime JARs, resources, and proxies can be loaded, and methods can be invoked, without the compiler having seen them before. 
Implementing this in a closed-world assumptions is problematic, as the universe must be known at build time, but not implementing these features would restrict too much the capabilities of Native Image.

In this section, we will go through the underlying mechanisms and assumptions used to implement these features, in both the JVM and Native Image.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Dynamic class loading}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Dynamic class loading~\cite{liang_dynamic_nodate} allows Java applications to load, link, and initialize classes at runtime, and more generally to install software components at runtime. Plugins for examples can be loaded and unloaded without restarting the application; dependency injection relies on late binding of dependencies, which is made possible with dynamic class loading. 

Class loaders are the underlying mechanism used for loading classes. 
%% problem when mentioning the interface of ClassLoader first and then going back to the types of classloaders...
There are two types of class loaders: the bootstrap (or system) class loader, which loads all the system classes, and user-defined class loaders, which load classes from user-defined sources.
Class loaders operate on a delegation model for loading classes or interfaces. If a class loader L directly loads C, then L in the \textit{defining loader} of C, otherwise L recursively delegate the loading to another class loader, until the defining loader of C is found. We say that L is an \textit{initiating loader} of C. 

Linking a class or interface C is done in three steps: (1) the JVM first verifies that the binary representation of the class or interface C is correct, (2) the static fields of C are created and initialized, (3) symbolic references are resolved into direct references. If C has a direct superclass or superinterface D, then D must also be verified and prepared. 

Concretely, a class loader in an instance of a subclass of the class \verb|ClassLoader|. 
Figure~\ref{fig:classloader}, shows the key methods of the class.

\begin{figure}[ht]
    \centering
\begin{lstlisting}[language=Java]
class ClassLoader {
    public Class<?> loadClass(String name);
    protected final Class<?> findLoadedClass(String name);
    static native Class<?> defineClass1(ClassLoader loader, String name, 
                                        byte[] b, int off, int len,
                                        ProtectionDomain pd, String source);
    static native Class<?> defineClass2(ClassLoader loader, String name, 
                                        java.nio.ByteBuffer b,
                                        int off, int len, ProtectionDomain pd,
                                        String source);
    static native Class<?> defineClass0(ClassLoader loader,
                                        Class<?> lookup,
                                        String name,
                                        byte[] b, int off, int len,
                                        ProtectionDomain pd,
                                        boolean initialize,
                                        int flags,
                                        Object classData);
    public static ClassLoader getSystemClassLoader();
    ...
}
\end{lstlisting}
    \caption{Core methods of the \texttt{ClassLoader} class}
    \label{fig:classloader}
\end{figure}


The method \verb|loadClass| is the entry point to initiate class loading. It can be called directly from user code, or triggered by a JVM instruction.
When loading a class \verb|C| (see Figure~\ref{fig:class_C}) with the system class loader, the JVM first checks, using the method \verb|findLoadedClass|, if \verb|C| has already been loaded. If this is not the case, then the class loader attempts to locate the corresponding data. As mentioned before, when linking C, the superclass D must also be linked, Finally the method \verb|defineClass0|, \verb|defineClass1| or \verb|defineClass2| is invoked to transform the array of bytes into a run-time representation of the class.

\begin{figure}[h]
    \centering
\begin{lstlisting}[language=Java]
class C extends D {
}
class Main {
    public static void main(String[] args) {
        ClassLoader cl = ClassLoader.getSystemClassLoader();
        Class<?> c = cl.loadClass("C");
    }
}
\end{lstlisting}
    \caption{Dynamically loading the class C.}
    \label{fig:class_C}
\end{figure}

% \subsubsection{Native Image implementation}
There are three main cases for how Native Image supports dynamic class loading: (1) the argument passed to \verb|loadClass| is a constant or is effectively constant, the argument is constant folded during static analysis, and becomes part of the image, (2) the class is included in the reachability metadata, (3) the class is not a constant, nor is it registered, in which case the image will throw an exception at runtime.


% Every Java class used at build time is said to be build-time initialized. Note that merely loading a class does not necessarily initialize it. The static class initializer of build-time initialized classes executes on the JVM running the image build. If a class is initialized at build time, its static fields are saved in the produced binary. At run time, using such a class for the first time does not trigger class initialization.
% 
% Static analysis is a process that determines which program elements (classes, methods and fields) are used by an application. These elements are also referred to as reachable code. The analysis itself has two parts:

% Scanning the bytecodes of a method to determine what other elements are reachable from it.
% Scanning the root objects in the native image heap (i.e., static fields) to determine which classes are reachable from them. It starts from the entry points of the application (i.e., the main method). The newly discovered elements are iteratively scanned until further scanning yields no additional changes in element’s reachability.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The invokedynamic bytecode instruction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

~\cite{rose_bytecodes_2009}
Talk about the usage, Method Handles, CallSites and BootStrap methods and how it required dynamic class loading
The JVM invokedynamic instruction was introduced in Java 7. It makes it possible to resolve method calls dynamically at runtime. method dispatch process by using a user-defined bootstrap method that computes the call target.
The above example uses a LambdaMetafactory to create a CallSite that is used to invoke the target method. It uses a MethodHandles.Lookup to find the target method.
The runtime approach is usually reflection-based and, consequently, inefficient. On the other hand, the compile-time solution is generally relying on code generation at compile-time. 
-> what are the case where it should throw bevaue it interprets user code?

https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-5.html#jvms-5.4.3.6
To resolve an unresolved symbolic reference R to a dynamically-computed constant or call site, there are three tasks. First, R is examined to determine which code will serve as its bootstrap method, and which arguments will be passed to that code. Second, the arguments are packaged into an array and the bootstrap method is invoked. Third, the result of the bootstrap method is validated, and used as the result of resolution.

The first task involves the following steps:

    R gives a symbolic reference to a bootstrap method handle. The bootstrap method handle is resolved (§5.4.3.5) to obtain a reference to an instance of java.lang.invoke.MethodHandle.

    Any exception that can be thrown as a result of failure of resolution of a symbolic reference to a method handle can be thrown in this step.

    If R is a symbolic reference to a dynamically-computed constant, then let D be the type descriptor of the bootstrap method handle. (That is, D is a reference to an instance of java.lang.invoke.MethodType.) The first parameter type indicated by D must be java.lang.invoke.MethodHandles.Lookup, or else resolution fails with a BootstrapMethodError. For historical reasons, the bootstrap method handle for a dynamically-computed call site is not similarly constrained.

    If R is a symbolic reference to a dynamically-computed constant, then it gives a field descriptor.

    If the field descriptor indicates a primitive type, then a reference to the pre-defined Class object representing that type is obtained (see the method isPrimitive in class Class).

    Otherwise, the field descriptor indicates a class or interface type, or an array type. A reference to the Class object representing the type indicated by the field descriptor is obtained, as if by resolution of an unresolved symbolic reference to a class or interface (§5.4.3.1) whose name corresponds to the type indicated by the field descriptor.

    Any exception that can be thrown as a result of failure of resolution of a symbolic reference to a class or interface can be thrown in this step.

    If R is a symbolic reference to a dynamically-computed call site, then it gives a method descriptor.

    A reference to an instance of java.lang.invoke.MethodType is obtained, as if by resolution of an unresolved symbolic reference to a method type (§5.4.3.5) with the same parameter and return types as the method descriptor.

    Any exception that can be thrown as a result of failure of resolution of a symbolic reference to a method type can be thrown in this step.


invokedynamic is a bytecode operation used to call arbitrary method within JVM. The exact method to be called and executed is unknown at a compile-time. Instead it is computed by object implementing CallSite. Thus the dynamic in invokedynamic.

CallSite objects, as any other, have to be instantiated. Boostrap Method is a method which instantiates CallSite objects.

Each invokedynamic has a known bootstrap method given as its compile-time parameter. Whenever a invokedynamic is processed for a first time, appropriate bootstrap method is invoked. As result of boostrap method execution a CallSite object is created. This CallSite object is then cached and associated by JVM to a given invokedynamic operation. From now on, whenever particular invokedynamic call is to be executed, a cached CallSite instance is used to resolve called method.

Majority of boostrap methods are not written directly by end Java programmer. However that doesn't mean they are some rare obscure mechanism. They are created by javac compiler whenever particular java statements are used within source. String concatenation or lambda expression come to mind.

For example lambda expression could be implemented as inner classes. For matter of fact, lambdas are presented to programmers 'as shorthand' to using inner classes. However actual javac implementation, for performance reasons, avoids inner classes by generating lambda code under a static method and using invokedynamic to invoke this method.


This specification allows an implementation flexibility as to when linking activities (and, because of recursion, loading) take place, provided that all of the following properties are maintained:

    A class or interface is completely loaded before it is linked.

    A class or interface is completely verified and prepared before it is initialized.

    Errors detected during linkage are thrown at a point in the program where some action is taken by the program that might, directly or indirectly, require linkage to the class or interface involved in the error.

    A symbolic reference to a dynamically-computed constant is not resolved until either (i) an ldc, ldc_w, or ldc2_w instruction that refers to it is executed, or (ii) a bootstrap method that refers to it as a static argument is invoked.

    A symbolic reference to a dynamically-computed call site is not resolved until a bootstrap method that refers to it as a static argument is invoked.

In Java, a class is initialized when it is first used. Native Image, can initialize them at build time, as a result using the class at runtime does not re-trigger class initialization.


\subsubsection{Java implementation}
Talk about the bootstrap method invokers, invokers, lanbdametafactory and altmetafactory and lambdaforms -> interpretation until the lambdaform is
considered to be hot enough to be compiled, customized, uncustomized if needed, cf tiered compilation
\subsubsection{Native Image implementaiton}
Some are compiled at image built time (indy and trusted condy BSM), the other are forced interpreted


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Reflection}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Java implementation}

\subsubsection{Native Image implementation}
Reachability Metadata and Tracing Agent

 \subsection{Computing Reflection Metadata in code}

Some reflection methods are treated specially and are evaluated at build time when given constant arguments.

Below are examples of calls that are replaced with the corresponding metadata element:

```java
Class.forName("java.lang.Integer")
Class.forName("java.lang.Integer", true, ClassLoader.getSystemClassLoader())
Class.forName("java.lang.Integer").getMethod("equals", Object.class)
Integer.class.getDeclaredMethod("bitCount", int.class)
Integer.class.getConstructor(String.class)
Integer.class.getDeclaredConstructor(int.class)
Integer.class.getField("MAX\_VALUE")
Integer.class.getDeclaredField("value")
```
