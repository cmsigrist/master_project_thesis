
@misc{noauthor_java_nodate,
	title = {Java {Programming} {Language}},
	url = {https://docs.oracle.com/javase/8/docs/technotes/guides/language/index.html},
	urldate = {2024-02-24},
}

@misc{dannarapu_jvm_2023,
	title = {{JVM} {Architecture}},
	url = {https://medium.com/javarevisited/jvm-architecture-32def70b6de},
	abstract = {JVM (Java Virtual Machine) is a software that interprets and executes Java code. Here’s a simple way to understand its architecture:},
	language = {en},
	urldate = {2024-02-24},
	journal = {Javarevisited},
	author = {Dannarapu, Srikanth},
	month = apr,
	year = {2023},
}

@misc{noauthor_scala_nodate,
	title = {Scala {Native} — {Scala} {Native} 0.4.17 documentation},
	url = {https://scala-native.org/en/stable/},
	language = {en},
	urldate = {2024-02-18},
}

@misc{noauthor_scala_2020,
	title = {Scala {Native} now supports reflective instantiation - {Announcements}},
	url = {https://contributors.scala-lang.org/t/scala-native-now-supports-reflective-instantiation/4198},
	abstract = {Hello everyone!  At the Scala Center we are happy to announce that reflective instantiation has been merged to the Scala Native master branch.  Reflective instantiation allows libraries and frameworks to reflectively instantiate modules and classes that are annotated with the @EnableReflectiveInstantiation annotation.  Here is a simple usage example:  import scala.scalanative.reflect.Reflect import scala.scalanative.reflect.annotation.EnableReflectiveInstantiation  object Main \{\vphantom{\}}   def main(args:...},
	language = {en},
	urldate = {2024-02-18},
	journal = {Scala Contributors},
	month = apr,
	year = {2020},
	note = {Section: Announcements},
}

@misc{noauthor_pitch_2022,
	title = {Pitch \#3: {Opt}-in {Reflection} metadata - {Evolution} / {Pitches}},
	shorttitle = {Pitch \#3},
	url = {https://forums.swift.org/t/pitch-3-opt-in-reflection-metadata/58852},
	abstract = {It's been a while since the last iteration on the Opt-In Reflection metadata proposal, but we've been working with @Joe\_Groff, @ctp and @mren on the updated version recently and while finishing the last bits, we would like to get the community's feedback on the new pieces in the proposal.   TL;DR Reflectable is a marker protocol now and developers can express the dependency on Reflection metadata as a generic requirement.  We decided not to pursue Reflection symbols stripability and instead focu...},
	language = {en},
	urldate = {2024-02-18},
	journal = {Swift Forums},
	month = jul,
	year = {2022},
	note = {Section: Evolution},
}

@inproceedings{rose_bytecodes_2009,
	address = {New York, NY, USA},
	series = {{VMIL} '09},
	title = {Bytecodes meet combinators: invokedynamic on the {JVM}},
	isbn = {978-1-60558-874-2},
	shorttitle = {Bytecodes meet combinators},
	url = {https://dl.acm.org/doi/10.1145/1711506.1711508},
	doi = {10.1145/1711506.1711508},
	abstract = {The Java Virtual Machine (JVM) has been widely adopted in part because of its classfile format, which is portable, compact, modular, verifiable, and reasonably easy to work with. However, it was designed for just one language---Java---and so when it is used to express programs in other source languages, there are often "pain points" which retard both development and execution. The most salient pain points show up at a familiar place, the method call site. To generalize method calls on the JVM, the JSR 292 Expert Group has designed a new invokedynamic instruction that provides user-defined call site semantics. In the chosen design, invokedynamic serves as a hinge-point between two coexisting kinds of intermediate language: bytecode containing dynamic call sites, and combinator graphs specifying call targets. A dynamic compiler can traverse both representations simultaneously, producing optimized machine code which is the seamless union of both kinds of input. As a final twist, the user-defined linkage of a call site may change, allowing the code to adapt as the application evolves over time. The result is a system balancing the conciseness of bytecode with the dynamic flexibility of function pointers.},
	urldate = {2024-02-18},
	booktitle = {Proceedings of the {Third} {Workshop} on {Virtual} {Machines} and {Intermediate} {Languages}},
	publisher = {Association for Computing Machinery},
	author = {Rose, John R.},
	month = oct,
	year = {2009},
	keywords = {bytecode, combinator, dynamic compilation, invokedynamic, method invocation},
	pages = {1--11},
}

@inproceedings{wurthinger_one_2013,
	address = {Indianapolis Indiana USA},
	title = {One {VM} to rule them all},
	isbn = {978-1-4503-2472-4},
	url = {https://dl.acm.org/doi/10.1145/2509578.2509581},
	doi = {10.1145/2509578.2509581},
	abstract = {Building high-performance virtual machines is a complex and expensive undertaking; many popular languages still have low-performance implementations. We describe a new approach to virtual machine (VM) construction that amortizes much of the effort in initial construction by allowing new languages to be implemented with modest additional effort. The approach relies on abstract syntax tree (AST) interpretation where a node can rewrite itself to a more specialized or more general node, together with an optimizing compiler that exploits the structure of the interpreter. The compiler uses speculative assumptions and deoptimization in order to produce efﬁcient machine code. Our initial experience suggests that high performance is attainable while preserving a modular and layered architecture, and that new highperformance language implementations can be obtained by writing little more than a stylized interpreter.},
	language = {en},
	urldate = {2024-02-18},
	booktitle = {Proceedings of the 2013 {ACM} international symposium on {New} ideas, new paradigms, and reflections on programming \& software},
	publisher = {ACM},
	author = {Würthinger, Thomas and Wimmer, Christian and Wöß, Andreas and Stadler, Lukas and Duboscq, Gilles and Humer, Christian and Richards, Gregor and Simon, Doug and Wolczko, Mario},
	month = oct,
	year = {2013},
	pages = {187--204},
}

@inproceedings{tip_practical_1999,
	address = {New York, NY, USA},
	series = {{OOPSLA} '99},
	title = {Practical experience with an application extractor for {Java}},
	isbn = {978-1-58113-238-0},
	url = {https://dl.acm.org/doi/10.1145/320384.320414},
	doi = {10.1145/320384.320414},
	abstract = {Java programs are routinely transmitted over low-bandwidth network connections as compressed class file archives (i.e., zip files and jar files). Since archive size is directly proportional to download time, it is desirable for applications to be as small as possible. This paper is concerned with the use of program transformations such as removal of dead methods and fields, inlining of method calls, and simplification of the class hierarchy for reducing application size. Such “extraction” techniques are generally believed to be especially useful for applications that use class libraries, since typically only a small fraction of a library's functionality is used. By “pruning away” unused library functionality, application size can be reduced dramatically. We implemented a number of application extraction techniques in Jax, an application extractor for Java, and evaluate their effectiveness on a set of realistic benchmarks ranging from 27 to 2,332 classes (with archives ranging from 56,796 to 3,810,120 bytes). We report archive size reductions ranging from 13.4\% to 90.2\% (48.7\% on average).},
	urldate = {2024-02-13},
	booktitle = {Proceedings of the 14th {ACM} {SIGPLAN} conference on {Object}-oriented programming, systems, languages, and applications},
	publisher = {Association for Computing Machinery},
	author = {Tip, Frank and Laffra, Chris and Sweeney, Peter F. and Streeter, David},
	month = oct,
	year = {1999},
	pages = {292--305},
}

@article{wimmer_initialize_2019,
	title = {Initialize once, start fast: application initialization at build time},
	volume = {3},
	issn = {2475-1421},
	shorttitle = {Initialize once, start fast},
	url = {https://dl.acm.org/doi/10.1145/3360610},
	doi = {10.1145/3360610},
	abstract = {Arbitrary program extension at run time in language-based VMs, e.g., Java's dynamic class loading, comes at a startup cost: high memory footprint and slow warmup. Cloud computing amplifies the startup overhead. Microservices and serverless cloud functions lead to small, self-contained applications that are started often. Slow startup and high memory footprint directly affect the cloud hosting costs, and slow startup can also break service-level agreements. Many applications are limited to a prescribed set of pre-tested classes, i.e., use a closed-world assumption at deployment time. For such Java applications, GraalVM Native Image offers fast startup and stable performance.
            GraalVM Native Image uses a novel iterative application of points-to analysis and heap snapshotting, followed by ahead-of-time compilation with an optimizing compiler. Initialization code can run at build time, i.e., executables can be tailored to a particular application configuration. Execution at run time starts with a pre-populated heap, leveraging copy-on-write memory sharing. We show that this approach improves the startup performance by up to two orders of magnitude compared to the Java HotSpot VM, while preserving peak performance. This allows Java applications to have a better startup performance than Go applications and the V8 JavaScript VM.},
	language = {en},
	number = {OOPSLA},
	urldate = {2024-02-11},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Wimmer, Christian and Stancu, Codrut and Hofer, Peter and Jovanovic, Vojin and Wögerer, Paul and Kessler, Peter B. and Pliss, Oleg and Würthinger, Thomas},
	month = oct,
	year = {2019},
	pages = {1--29},
}

@misc{noauthor_hotspot_nodate,
	title = {{HotSpot} {Group}},
	url = {https://openjdk.org/groups/hotspot/},
	urldate = {2024-02-11},
}

@misc{noauthor_common_2012,
	title = {Common {Language} {Infrastructure} ({CLI})},
	url = {https://ecma-international.org/wp-content/uploads/ECMA-335_6th_edition_june_2012.pdf},
	month = jun,
	year = {2012},
}

@misc{noauthor_ecma-335_nodate,
	title = {{ECMA}-335},
	url = {https://ecma-international.org/publications-and-standards/standards/ecma-335/},
	abstract = {Common Language Infrastructure (CLI) - Defines the infrastructure in which applications written in multiple high-level languages can be executed},
	language = {en-US},
	urldate = {2024-02-11},
	journal = {Ecma International},
}

@misc{noauthor_clr_2019,
	title = {{CLR} {Inside} {Out}: {The} {Performance} {Benefits} of {NGen}.},
	shorttitle = {{CLR} {Inside} {Out}},
	url = {https://learn.microsoft.com/en-us/archive/msdn-magazine/2006/may/clr-inside-out-the-performance-benefits-of-ngen},
	language = {en-us},
	urldate = {2024-02-04},
	month = oct,
	year = {2019},
}

@misc{noauthor_common_2023,
	title = {Common {Language} {Runtime} ({CLR}) overview - .{NET}},
	url = {https://learn.microsoft.com/en-us/dotnet/standard/clr},
	abstract = {Get started with common language runtime (CLR), .NET's run-time environment. The CLR runs code and provides services to make the development process easier.},
	language = {en-us},
	urldate = {2024-02-04},
	month = apr,
	year = {2023},
}

@misc{kexugit_clr_2019,
	title = {{CLR} {Inside} {Out}: {The} {Performance} {Benefits} of {NGen}.},
	shorttitle = {{CLR} {Inside} {Out}},
	url = {https://learn.microsoft.com/en-us/archive/msdn-magazine/2006/may/clr-inside-out-the-performance-benefits-of-ngen},
	language = {en-us},
	urldate = {2024-02-11},
	author = {kexugit},
	month = oct,
	year = {2019},
}

@misc{gewarren_common_2023,
	title = {Common {Language} {Runtime} ({CLR}) overview - .{NET}},
	url = {https://learn.microsoft.com/en-us/dotnet/standard/clr},
	abstract = {Get started with common language runtime (CLR), .NET's run-time environment. The CLR runs code and provides services to make the development process easier.},
	language = {en-us},
	urldate = {2024-02-11},
	author = {gewarren},
	month = apr,
	year = {2023},
}

@misc{noauthor_java_nodate-1,
	title = {The {Java}® {Virtual} {Machine} {Specification}},
	url = {https://docs.oracle.com/javase/specs/jvms/se21/html/index.html},
	urldate = {2024-01-28},
}

@misc{noauthor_java_nodate-2,
	title = {The {Java}® {Language} {Specification}},
	url = {https://docs.oracle.com/javase/specs/jls/se21/html/index.html},
	urldate = {2023-12-20},
}

@misc{alex_ber_explaining_2020,
	title = {Explaining invokedynamic. {Bootstrap} method. {Part} {III}},
	url = {https://alex-ber.medium.com/explaining-invokedynamic-bootstrap-method-part-iii-af414bd73fda},
	abstract = {This is third part of mini-series of Explaining invokedynamic. This is the full list of all articles:},
	language = {en},
	urldate = {2024-02-04},
	journal = {Medium},
	author = {alex\_ber},
	month = sep,
	year = {2020},
}

@article{azevedo_annotation-aware_2000,
	title = {An annotation-aware {Java} virtual machine implementation},
	volume = {12},
	copyright = {Copyright © 2000 John Wiley \& Sons, Ltd.},
	issn = {1096-9128},
	url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/1096-9128%28200005%2912%3A6%3C423%3A%3AAID-CPE483%3E3.0.CO%3B2-L},
	doi = {10.1002/1096-9128(200005)12:6<423::AID-CPE483>3.0.CO;2-L},
	abstract = {The Java bytecode language lacks expressiveness for traditional compiler optimizations, making this portable, secure software distribution format inefficient as a program representation for high performance. This inefficiency results from the underlying stack model, as well as the fact that many bytecode operations intrinsically include sub-operations (e.g. iaload includes the address computation, array bounds checks and the actual load of the array element). The stack model, with no operand registers and limiting access to the top of the stack, prevents the re-use of values and bytecode re-ordering. In addition, the language has no mechanism to indicate which sub-operations in the Java bytecode stream are redundant or subsumed by previous ones. As a consequence, the Java bytecode language inhibits the expression of important compiler optimizations, including register allocation and instruction scheduling. The Java bytecode stream generated by a Java bytecode compiler is a significantly under-optimized program representation. The most common solution to overcome this inefficiency is the use of a just-in-time (JIT) compiler to not only generate native code, but perform optimization as well. However, the latter is a time-consuming operation in an already time-constrained translation process. In this paper we present an alternative to an optimizing JIT compiler that makes use of code annotations generated by a Java bytecode compiler. These annotations carry information concerning compiler optimizations. During the translation process, an annotation-aware Java Virtual Machine (JVM) system then uses this information to produce high-performance native code without performing much of the necessary analyses or transformations. We describe the implementation of a prototype of an annotation-aware JVM consisting of an annotation-aware JIT compilation system. We conclude the paper showing performance results comparing our system with other JVMs running on SPARC architecture. Copyright © 2000 John Wiley \& Sons, Ltd.},
	language = {en},
	number = {6},
	urldate = {2024-02-04},
	journal = {Concurrency: Practice and Experience},
	author = {Azevedo, Ana and Nicolau, Alex and Hummel, Joe},
	year = {2000},
	note = {\_eprint: https://onlinelibrary.wiley.com/doi/pdf/10.1002/1096-9128\%28200005\%2912\%3A6\%3C423\%3A\%3AAID-CPE483\%3E3.0.CO\%3B2-L},
	keywords = {JIT compilation, Java Bytecode, Java Virtual Machine, code annotation, dynamic compilation},
	pages = {423--444},
}

@misc{noauthor_ecmascript_nodate,
	title = {{ECMAScript}® 2024 {Language} {Specificatio}},
	url = {https://tc39.es/ecma262/#sec-strict-mode-of-ecmascript},
	abstract = {The Strict Mode of ECMAScript},
}

@misc{noauthor_v8_nodate,
	title = {V8},
	url = {https://v8.dev/blog/v8-release-74},
}

@article{liang_dynamic_nodate,
	title = {Dynamic {Class} {Loading} in the {JavaTMVirtual} {Machine}},
	abstract = {Class loaders are a powerful mechanism for dynamically loading software components on the Java platform. They are unusual in supporting all of the following features: laziness,type-q? linkage, user-definedextensibility, and multiple communicating namespaces. We present the notion of class loaders and demonstrate some of their interesting uses. In addition, we discuss how to maintain type safety in the presence of user-defined dynamic class loading.},
	language = {en},
	author = {Liang, Sheng and Bracha, Gilad},
}

@article{poletto_c_1999,
	title = {C and tcc: a language and compiler for dynamic code generation},
	volume = {21},
	issn = {0164-0925, 1558-4593},
	shorttitle = {C and tcc},
	url = {https://dl.acm.org/doi/10.1145/316686.316697},
	doi = {10.1145/316686.316697},
	abstract = {Dynamic code generation allows programmers to use run-time information in order to achieve performance and expressiveness superior to those of static code. The 'C(
              Tick C
              ) language is a superset of ANSI C that supports efficient and high-level use of dynamic code generation. 'C provides dynamic code generation at the level of C expressions and statements and supports the composition of dynamic code at run time. These features enable programmers to add dynamic code generation to existing C code incrementally and to write important applications (such as “just-in-time” compilers) easily. The article presents many examples of how 'C can be used to solve practical problems. The tcc compiler is an efficient, portable, and freely available implementation of 'C. tcc allows programmers to trade dynamic compilation speed for dynamic code quality: in some aplications, it is most important to generate code quickly, while in others code quality matters more than compilation speed. The overhead of dynamic compilation is on the order of 100 to 600 cycles per generated instruction, depending on the level of dynamic optimizaton. Measurements show that the use of dynamic code generation can improve performance by almost an order of magnitude; two- to four-fold speedups are common. In most cases, the overhead of dynamic compilation is recovered in under 100 uses of the dynamic code; sometimes it can be recovered within one use.},
	language = {en},
	number = {2},
	urldate = {2024-02-04},
	journal = {ACM Transactions on Programming Languages and Systems},
	author = {Poletto, Massimiliano and Hsieh, Wilson C. and Engler, Dawson R. and Kaashoek, M. Frans},
	month = mar,
	year = {1999},
	pages = {324--369},
}

@misc{noauthor_java_2024,
	title = {Java version history},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Java_version_history&oldid=1197124757},
	abstract = {The Java language has undergone several changes since JDK 1.0 as well as numerous additions of classes and packages to the standard library. Since J2SE 1.4, the evolution of the Java language has been governed by the Java Community Process (JCP), which uses Java Specification Requests (JSRs) to propose and specify additions and changes to the Java platform. The language is specified by the Java Language Specification (JLS); changes to the JLS are managed under JSR 901. In September 2017, Mark Reinhold, chief Architect of the Java Platform, proposed to change the release train to "one feature release every six months" rather than the then-current two-year schedule. This proposal took effect for all following versions, and is still the current release schedule.
In addition to the language changes, other changes have been made to the Java Class Library over the years, which has grown from a few hundred classes in JDK 1.0 to over three thousand in J2SE 5. Entire new APIs, such as Swing and Java2D, have been introduced, and many of the original JDK 1.0 classes and methods have been deprecated. Some programs allow conversion of Java programs from one version of the Java platform to an older one (for example Java 5.0 backported to 1.4) (see Java backporting tools).
Regarding Oracle Java SE Support Roadmap, version 21 is the latest one, and versions 21, 17, 11 and 8 are the currently supported long-term support (LTS) versions, where Oracle Customers will receive Oracle Premier Support. Oracle continues to release no-cost public Java 8 updates for development and personal use indefinitely. Oracle also continues to release no-cost public Java 17 LTS updates for all users, including commercial and production use until September 2024.In the case of OpenJDK, both commercial long-term support and free software updates are available from multiple organizations in the broader community.Java 21, the latest (4th) LTS, was released on September 19, 2023.},
	language = {en},
	urldate = {2024-01-28},
	journal = {Wikipedia},
	month = jan,
	year = {2024},
	note = {Page Version ID: 1197124757},
}

@article{serrano_quicksilver_2000,
	title = {Quicksilver: a quasi-static compiler for {Java}},
	volume = {35},
	issn = {0362-1340},
	shorttitle = {Quicksilver},
	url = {https://dl.acm.org/doi/10.1145/354222.353176},
	doi = {10.1145/354222.353176},
	abstract = {This paper presents the design and implementation of the Quicksilver1 quasi-static compiler for Java. Quasi-static compilation is a new approach that combines the benefits of static and dynamic compilation, while maintaining compliance with the Java standard, including support of its dynamic features. A quasi-static compiler relies on the generation and reuse of persistent code images to reduce the overhead of compilation during program execution, and to provide identical, testable and reliable binaries over different program executions. At runtime, the quasi-static compiler adapts pre-compiled binaries to the current JVM instance, and uses dynamic compilation of the code when necessary to support dynamic Java features. Our system allows interprocedural program optimizations to be performed while maintaining binary compatibility. Experimental data obtained using a preliminary implementation of a quasi-static compiler in the Jalape\&ntilde;o JVM clearly demonstrates the benefits of our approach: we achieve a runtime compilation cost comparable to that of baseline (fast, non-optimizing) compilation, and deliver the runtime program performance of the highest optimization level supported by the Jalape\&ntilde;o optimizing compiler. For the SPECjvm98 benchmark suite, we obtain a factor of 104 to 158 reduction in the runtime compilation overhead relative to the Jalape\&ntilde;o optimizing compiler. Relative to the better of the baseline and the optimizing Jalape\&ntilde;o compilers, the overall performance (taking into account both runtime compilation and execution costs) is increased by 9.2\% to 91.4\% for the SPECjvm98 benchmarks with size 100, and by 54\% to 356\% for the (shorter running) SPECjvm98 benchmarks with size 10.},
	number = {10},
	urldate = {2024-02-04},
	journal = {ACM SIGPLAN Notices},
	author = {Serrano, Mauricio and Bordawekar, Rajesh and Midkiff, Sam and Gupta, Manish},
	month = oct,
	year = {2000},
	pages = {66--82},
}

@inproceedings{engler_c_1996,
	address = {St. Petersburg Beach, Florida, United States},
	title = {C: a language for high-level, efficient, and machine-independent dynamic code generation},
	isbn = {978-0-89791-769-8},
	shorttitle = {C},
	url = {http://portal.acm.org/citation.cfm?doid=237721.237765},
	doi = {10.1145/237721.237765},
	abstract = {Dynamic code generation allows specialized code sequences to be created using runtime information. Since this information is by definition not available statically, the use of dynamic code generation can achieve performance inherently beyond that of static code generation. Previous attempts to support dynamic code generation have been low-level, expensive, or machinedependent. Despite the growing use of dynamic code generation, no mainstream language provides flexible, portable, and efficient support for it. We describe ‘C (Tick C), a superset of ANSI C that allows flexible, high-level. efficient, and machine-independent specification of dynamically generated code. ‘C provides many of the performance benefits of pure partial evaluation, but in the context of a complex, statically typed, but widely used language. ‘C examples illustrate the ease of specifying dynamically generated code and how it can be put to use. Experiments with a prototype compiler show that ‘C enables excellent performance improvement (in some cases, more than an order of magnitude).},
	language = {en},
	urldate = {2024-02-04},
	booktitle = {Proceedings of the 23rd {ACM} {SIGPLAN}-{SIGACT} symposium on {Principles} of programming languages  - {POPL} '96},
	publisher = {ACM Press},
	author = {Engler, Dawson R. and Hsieh, Wilson C. and Kaashoek, M. Frans},
	year = {1996},
	pages = {131--144},
}

@misc{noauthor_net_nodate,
	title = {.{NET} {\textbar} {Build}. {Test}. {Deploy}.},
	url = {https://dotnet.microsoft.com/en-us/},
	abstract = {.NET is a developer platform with tools and libraries for building any type of app, including web, mobile, desktop, games, IoT, cloud, and microservices.},
	language = {en-US},
	urldate = {2023-12-20},
	journal = {Microsoft},
}

@misc{noauthor_overview_nodate,
	title = {Overview},
	url = {https://www.graalvm.org/latest/docs/introduction/},
	abstract = {GraalVM is an advanced JDK with ahead-of-time Native Image compilation.},
	language = {en},
	urldate = {2023-12-20},
}

@misc{noauthor_native_nodate,
	title = {Native {Image}},
	url = {https://www.graalvm.org/latest/reference-manual/native-image/},
	abstract = {GraalVM is an advanced JDK with ahead-of-time Native Image compilation.},
	language = {en},
	urldate = {2023-12-20},
}

@misc{noauthor_native_nodate-1,
	title = {Native {Image} {Basics}},
	url = {https://www.graalvm.org/latest/reference-manual/native-image/basics/},
	abstract = {GraalVM is an advanced JDK with ahead-of-time Native Image compilation.},
	language = {en},
	urldate = {2023-12-20},
}

@misc{noauthor_chapter_nodate,
	title = {Chapter 5. {Loading}, {Linking}, and {Initializing}},
	url = {https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-5.html#jvms-5.4.3.6},
	urldate = {2023-12-20},
}
